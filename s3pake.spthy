theory s3pake
begin

builtins: diffie-hellman

functions: blind/2, unblind/2, G/3, Ha/3

equations: unblind(blind(a, b), b) = a

//защищенный канал для передачи пароля доверенному серверу
rule In_S:
    [ !Sec($A, $B, m) ]
    --[
        In_S($A, $B, m)
    ]->
    [ In_S($A, $B, m) ]

rule Out_S:
    [ Out_S($A, $B, m) ]
    --[
        Out_S($A, $B, m)
    ]->
    [ !Sec($A, $B, m) ]

//Генерация паролей пользователей при первом запуске протокола
rule Secret_keys_registration:
    [ Fr(~pw) ]
    -->
    [ !Ltk($client, ~pw)
    , Out_S($client, $S, ~pw) ]

//Моделирование протокола
rule A_send_init_message:
	let        
        X = blind('g'^~x, ('g'^$ordM)^~pwA)
    in    
    [ !Ltk($A, ~pwA)
    , Fr(~x) ]
    --[ 
        SendInitToB($A, X) 
    ]->
    [ Out(<$A, X>)
    , St_A_1($A, ~x, ~pwA, X) ]

rule B_receive_A_init_message:
	let
        Y = blind('g'^~y, ('g'^$ordN)^~pwB)
    in	
    [ !Ltk($B, ~pwB)
    , Fr(~y)
    , In(<$A, X>) ]
    --[ 
        SendInitToServer($A, X, $B, Y) 
    ]->
    [ Out(<$A, X, $B, Y>)
    , St_B_1($B, ~y, ~pwB, Y, $A, X) ]

/*
использовать секретные каналы 
https://tamarin-prover.github.io/manual/book/009_advanced-features.html
*/
rule S_receive_B_init_message:
    let
        g_power_x = unblind(X, ('g'^$ordM)^~pwA)
        g_power_y = unblind(Y, ('g'^$ordN)^~pwB)
        S_X = blind(g_power_x^~z, G($B, $S, g_power_y)^~pwB)
        S_Y = blind(g_power_y^~z, G($A, $S, g_power_x)^~pwA)
    in
    [ In_S($A, $S, ~pwA)
    , In_S($B, $S, ~pwB)
    , Fr(~z)
    , In(<$A, X, $B, Y>) ]
    -->
    [ Out(<S_X, S_Y>) ]

rule B_receive_answer_S:
	let
        g_power_xz = unblind(S_X, G($B, $S, 'g'^~y)^~pwB)
        alpha = G($A, $B, (g_power_xz)^~y)
    in
    [ St_B_1($B, ~y, ~pwB, Y, $A, X)
    , In(<S_X, S_Y>) ]
    --[
        SendAnswerToA(S_Y, alpha)
    ]->
    [ Out(<S_Y, alpha>)
    , St_B_2($B, ~y, ~pwB, g_power_xz) ]

rule A_receive_alpha_from_B:
	let
        g_power_yz = unblind(S_Y, G($A, $S, 'g'^~x)^~pwA)
        beta = G($B, $A, g_power_yz^~x)
        SK = Ha($A, $B, g_power_yz^~x)
    in
    [ St_A_1($A, ~x, ~pwA, X)
    , In(<S_Y, alpha>) ]
    --[
        
    ]->
    [ Out(beta)
    , A_Session($A, $B, SK) ]

rule B_receive_beta_from_A:
	let
        SK = Ha($A, $B, g_power_xz^~y)
    in
    [ St_B_2($B, ~y, ~pwB, g_power_xz)
    , In(beta) ]
    --[
        
    ]->
    [ B_Session($A, $B, SK) ]



lemma executable:
  exists-trace
    "Ex A B X Y #i #j. SendInitToB(A, X) @i & SendInitToServer(A,X,B,Y) @j & i < j"

end